function [filesOut, act, lm, qdd, options]=osStaticEquilibrateModel(osimModelName,polyP,objFunc,options)%osStaticEquilibrateModel - Get the activation and muscle length values that% that put a model in static equibrium.  This effectively performs static% optimization with all generalized coordinate acceleration = 0.%% This function works by performing an optmization to set all generalized%   coordinates (or roughly joints) to zero acceleration at the default%   pose of the model.%%[filesOut, act, lm, qdd, options]=osStaticEquilibrateModel(osimModelName,polyP,options)%%       Inputs:%               osimModelName - name of OpenSim Model%               polyP - power of muscle activation polynomial%                   Use the same value you typically use in OpenSim Static%                   Optimization (typically 2 or 3).%                   If polyP=Inf, this function will use the min-max%                   fatigue based formulation for the muscle activation%                   pattern (minimize the maximum activation function across the%                   muscles.%               objFunc - Objective Function Formulation%                   0 - activation only  (use this is you are matching%                           OpesnSim SO)%                       minimize: sum(  ai^polyP  )%                   1 - Scaled by the maximum force of all of the muscles%                       minimize: sum(  (ai*Fmaxi/Fmaxall) ^p)%                   2 - Scaled by the maximum force and volume of all of the muscles%                         Vol=Fmax*Lopt%                       minimize: sum(  (ai*Voli/Volmaxall) ^p)%               options - optional argument  [default values]%                   options.showPlot: 0 or 1 for showing convergence plot [0]%                   options.TolX:  Tolerance on activation stepping [1e-4]%                   options.MaxIter: max number of solver iterations [200]%                   options.MaxFunEvals: max number of objective evals [10000]%                   options.TolCon: tolerance on accel constraints being 0 [1e-4]%                   options.TolFun: tolerance on objective convergence []%                       If empty, this is calculated based on the objective%                       value with all muscles at minumum activations%                   options.filesuffix suffix to add to controls and states%                       file name ['_Equib']%%       Outputs:%               filesOut - Name of controls and state files created%               act - vector with muscle activation values%               lm - vector with muscle lengths%               qdd - generalized coordinates (joint) accelerations%               options- options used (see options in inputs)%%        Example:%           Run a simple Arm Model using OpenSim's standard Static Op%           settings:%%           [filesOut, act, lm, qdd, options]=osStaticEquibriateModel('Arm28_Optimize.osim',2,0);%%Troubleshooting:% If a joint is underactuated (there is not enough muscle force capability%   to hold at the joints at static equilibrium) this will fail.  You can%   get an idea of what jpint is under actuated by looking at the output%   "Best Constraint Value".  If a joint never gets near zero in the%   optimization, it is likely underactuated.  This is not full proof%   though, if for example tourso muscles are undersized and the model%   keeps "bending over at the hips) the knees will also have trouble%   maintaining zer acceleration.%% Make sure your model is constrained well.  For example is the pelvis or% the feet constrained or will the model "free-fall".  A free falliung% model will fail.%---------------------------------------------%Brad Humphreys 2016-2-16 v1.0%---------------------------------------------% Note do NOT attempt to use this as a template for full dyanmic motion% static optimization.  It only works for static systems.% This function uses the equibriateMuscles API function.% equibriateMuscles inherently calcualtes the muscle length% based on the muscle velocity being 0.%Default OptionsdefOptions.showPlot=0;defOptions.TolX = 1e-3;  %Resonable for activationsdefOptions.MaxIter=200;defOptions.MaxFunEvals=10000;defOptions.TolCon=1e-4;defOptions.TolFun=[];defOptions.filesuffix='_Equib';%Write the default options into options if they don't existif nargin<4    options=defOptions;else    optFields=getfields(defOptions);    for i=1:length(optFields)        fieldName=optFields{i};        if ~isfield( options,fieldName)            options.(fieldName)=defOptions.(fieldName);        end    endendglobal osimModel osimState nJoints nMuscles bestConst constVec nCoords  p showPlot cp=polyP;showPlot=options.showPlot;% Load Libraryimport org.opensim.modeling.*;% Open a Model by nameosimModel = Model(osimModelName);%Initialize ModelosimState = osimModel.initSystem();osimModel.computeStateVariableDerivatives(osimState);nJoints=osimModel.getJointSet().getSize();nMuscles=osimModel.getMuscles().getSize();nCoords=osimModel.getCoordinateSet().getSize();%Force all coordinate values to 0 velocity and get positionsfor i=1:nCoords    qName{i}=char(osimModel.getCoordinateSet().get(i-1).getName());  %Name    q(i)=osimModel.getCoordinateSet().get(i-1).getValue(osimState);  %Coord Angle    osimModel.getCoordinateSet().get(i-1).setSpeedValue(osimState,0);  %Coord Speedend%Get Muscle Properties for cost functionsfor m=1:nMuscles    forceObj=osimModel.getMuscles().get(i-1);        muscleMaxIsoForce(m)=osimModel.getMuscles().get(m-1).getMaxIsometricForce();    muscleOptimalFiberLength(m)=osimModel.getMuscles.get(m-1).getOptimalFiberLength();        muscleType = char(forceObj.getConcreteClassName);    eval(['muscleObj =' muscleType '.safeDownCast(forceObj);']);        muscleMinAct(m)=muscleObj.getDefaultActivation;    muscleMaxAct(m)=1;endmuscleVolScale=muscleMaxIsoForce.*muscleOptimalFiberLength;%Choose which type of objective functions scaling to use:if objFunc==0    %% activation only    c=ones(1,nMuscles)/(nMuscles);    %This is basically the default in OpenSimelseif objFunc==1    %% Scaled by muscle max iso force    c=muscleMaxIsoForce./max(muscleMaxIsoForce);elseif objFunc==2    %% Scaled by muscle max force and volume    c=muscleVolScale./max(muscleVolScale);else    error('objFun is not correctly defined.')endc=c(:)';%These will be needed to store the best result for the constraintsbestConst=Inf;constVec=Inf*ones(1,nCoords);X0=muscleMinAct + 0.5*(muscleMaxAct-muscleMinAct);  %Initial guess is 50% activation%If I use min activation, the model slowly converges (likely because of the%slow initial gardiant in the objective (I also tried using the TypicalX%parameter).if p==Inf   %For minmax objective, add slack variable    X0=[X0 min(X0)];    muscleMinAct=[muscleMinAct 0];    muscleMaxAct=[muscleMaxAct Inf];end%Run the optimizationact=runFminconOpt(X0,muscleMinAct,muscleMaxAct,options);%Print Results:fprintf('Best Constraint Norm Eval (ideally should be 0): %g\n',bestConst)fprintf('Joint Best Constraint Value (ideal = 0)\n');for i=1:nCoords    fprintf('%s: %g\n',qName{i},constVec(i))end%Calculate resulting accelerations[qdd,lm]=evalModel(act);  %Get the resulting constraint values%Organize the data to make a controls and states output file%TBD - Make a helper function that does thisstFileHead={'time'};contFileHead={'time'};for i=1:nCoords    jName{i}=char(osimModel.getCoordinateSet().get(i-1).getName());    stFileHead=[stFileHead jName{i} [jName{i} '_u']];endstData=[];for i=1:nCoords    stData=[stData q(i) 0];endfor i=1:nMuscles    mName{i}=char(osimModel.getMuscles().get(i-1).getName());    stFileHead=[stFileHead [mName{i} '.activation'] [mName{i} '.fiber_length']];    contFileHead=[contFileHead mName{i}];    stData=[stData act(i) lm(i)];endt=[0:0.1:1]';contData=repmat(act,11,1);contData=[t contData];stData=repmat(stData,11,1);stData=[t stData];%Create output filenamesfileNameBase=strrep(osimModelName,'.osim','');filesOut{1}=[fileNameBase options.filesuffix '_controls.sto'];filesOut{2}=[fileNameBase options.filesuffix '_states.sto'];%Create the controls and state filesosMakeControlsFileSimple(filesOut{1},contFileHead,contData,0);osMakeControlsFileSimple(filesOut{2},stFileHead,stData,0);end%=========================================================function X=runFminconOpt(X0,lb,ub,options)%Setup and run fmincon%   Inputs:%       X0: Initial guess at muscle activations%       lb: minimum allowable muscle activations%       ub: maximum allowable muscle activation%       options:  see fmincon%   Outputs:%       X:  Muscle Activationsif isempty(options.TolFun)    options.TolFun = objfun(lb);endfun= @(X) objfun(X);A=[];b=[];Aeq=[];beq=[];nonlcon=@(X) mycon(X);fminoptions=optimoptions('fmincon');fminoptions=optimoptions(fminoptions,'GradObj','on',...    'Display','iter-detailed','MaxIter',options.MaxIter,...    'MaxFunEvals',options.MaxFunEvals,'TolCon',options.TolCon,...    'TolX',options.TolX,'TolFun',options.TolFun);[X,fval,exitflag,output]=fmincon(fun,X0,A,b,Aeq,beq,lb,ub,nonlcon,fminoptions);end%=========================================================function [F G]= objfun(X)% objective function to be used by fmincon%   Inputs: %       X: muscle activations%   Outputs:%       F: objective function value%       G: gradiant of objective function wrt each muscle activationglobal p  c nMusclesif p<Inf   %Polynomial Case    F = 1/p/nMuscles/sum(c.^p) * sum((c.*X).^p);else   %Minmax case    F=X(end);endif nargout==2    G = objgrad(X);endend%=========================================================function G = objgrad(X)% calculate the gradiant of the objective function%   Inputs: %       X: muscle activations%   Outputs:%       G: gradiant of objective function wrt each muscle activationglobal objGradArray p c nMusclesif p<Inf  %Polynomial Case    G = 1/nMuscles/sum(c.^p) * (c.^p .* X.^(p-1));else   %Minmax case    G=zeros(size(X,1),size(X,2));    G(end)=1;endend%=========================================================function [c,ceq] = mycon(X)% Constraint function - calculate the acceleration at each generalized% coord (joint)%   Inputs: %       X: muscle activations%   Outputs:%       c: inequaility constraint value%       ceq: equaility constraint valueglobal p showPlotceq=evalModel(X);  %Equality constraints at X;if showPlot    %[norm(ceq) norm(X)]    figure(1)    subplot(2,1,1)    plot(X)    hold on    ylabel('X')    subplot(2,1,2)    plot(ceq)    hold on    ylabel('Constraints')    drawnow()endif p==Inf  %minmax    s=X(end);    a=X(1:end-1);    c=a-s;else   %polynomial    c=[];endend%=========================================================function [qdd,lm]=evalModel(X)% evalModel - run the model to get the accelerations and the muscle lengths%   Inputs: %       X: muscle activations%   Outputs:%       qdd - acceleration values of the generalized coordinates (trying to%           get these to be 0)%       lm - muscle fiber lengthsglobal osimModel osimState nMuscles bestConst constVec nCoords% Load Libraryimport org.opensim.modeling.*;for i=1:nMuscles        forceObj=osimModel.getMuscles().get(i-1);        %For Millard2012 Muscles, you have to change the default activation    %(regular activation does not work)  per: https://simtk.org/forums/viewtopic.php?f=91&t=5308    %As of OpenSim 3.3 this is still an issue    if strcmp(forceObj.getConcreteClassName, ...            'Millard2012EquilibriumMuscle')                muscleType = char(forceObj.getConcreteClassName);        eval(['muscleObj =' muscleType '.safeDownCast(forceObj);']);        muscleObj.setDefaultActivation(X(i));            else                forceObj.setActivation(osimState,X(i))            end        endosimModel.equilibrateMuscles(osimState);osimModel.computeStateVariableDerivatives(osimState);for i=1:nCoords    qdd(i)=osimModel.getCoordinateSet().get(i-1).getAccelerationValue(osimState);endfor i=1:nMuscles    lm(i)=osimModel.getMuscles().get(i-1).getFiberLength(osimState);endbestConst=min(norm(qdd),bestConst);constVec=min([constVec;abs(qdd)]);end